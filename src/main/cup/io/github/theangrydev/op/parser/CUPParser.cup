package io.github.theangrydev.op.parser;

import java_cup.runtime.ComplexSymbolFactory.Location;

import java.util.LinkedList;
import java.util.List;

/* Parser code */
parser code {:
    private io.github.theangrydev.op.parser.Location location(Location left, Location right) {
        return io.github.theangrydev.op.parser.Location.between(left, right);
    }
:};

/* Terminals (tokens returned by the scanner) */
terminal AND, OR;
terminal EQUAL_TO, LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUAL_TO, GREATER_THAN_OR_EQUAL_TO, NOT_EQUAL_TO;
terminal TIMES, PLUS, MINUS, DIVIDE;
terminal IF, ELSE;
terminal ASSIGNMENT;
terminal String IDENTIFIER;
terminal CODE, API;
terminal SEMICOLON, COMMA, LEFT_PARENTHESIS, RIGHT_PARENTHESIS, COLON, DOT;
terminal Integer INTEGER;
terminal Double REAL;
terminal String STRING;

/* Non terminals */
non terminal Statement Statement;
non terminal List<Statement> StatementList;
non terminal Expression Expression;
non terminal Program Program;
non terminal TypeDeclaration TypeDeclaration;
non terminal TypeExpression TypeExpression;
non terminal IntegerConstant IntegerConstant;
non terminal RealConstant RealConstant;
non terminal StringConstant StringConstant;

/* Precedences */
precedence left PLUS, MINUS, TIMES, DIVIDE;

/* Start symbol */
start with Program;

/* The grammar rules */
Program ::= StatementList:statementList                                         {: RESULT=Program.of(statementList); :}
    ;
StatementList ::= Statement:statement SEMICOLON StatementList:statementList     {: statementList.add(statement); RESULT=statementList; :}
    | /* Empty StatementList */                                                 {: RESULT=new LinkedList<Statement>(); :}
    ;
Statement ::= TypeDeclaration:typeDeclaration ASSIGNMENT Expression:expression  {: RESULT=TypeDeclarationAssignment.of(typeDeclaration, expression); :}
    | TypeExpression:type ASSIGNMENT Expression:expression                      {: RESULT=ExistingTypeAssignment.of(type, expression); :}
    ;
TypeDeclaration ::= TypeExpression:targetType COLON TypeExpression:existingType {: RESULT=TypeDeclaration.of(targetType, existingType); :}
    ;
TypeExpression ::= IDENTIFIER:type                                              {: RESULT=TypeExpression.of(location(typexleft, typexright), type); :}
    ;
Expression ::= INTEGER:value                                                    {: RESULT=IntegerConstant.of(location(valuexleft, valuexright), value); :}
    | REAL:value                                                                {: RESULT=RealConstant.of(location(valuexleft, valuexright), value); :}
    | STRING:value                                                              {: RESULT=StringConstant.of(location(valuexleft, valuexright), value); :}
    | TypeExpression:type                                                       {: RESULT=type; :}
    | Expression:left PLUS Expression:right                                     {: RESULT=Addition.add(left, right); :}
    ;
