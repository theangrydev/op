package io.github.theangrydev.op.parser;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.Symbol;

import java.util.LinkedList;
import java.util.List;

/* Parser code */
parser code {:
    private static final int RECOVERY_ERROR_LOOKAHEAD_SIZE = 3;
    private int errorLookAheadSize = RECOVERY_ERROR_LOOKAHEAD_SIZE;
    private SyntaxError syntaxError;

    private io.github.theangrydev.op.parser.Location location(Location left, Location right) {
        return io.github.theangrydev.op.parser.Location.between(left, right);
    }

    @Override
    public void syntax_error(Symbol currentToken) {
        syntaxError = SyntaxError.of((ComplexSymbol) this.stack.peek(), (ComplexSymbol) currentToken, expected_token_ids());
    }

    @Override
    public List<Integer> expected_token_ids() {
        errorLookAheadSize = 1;
        List<Integer> expectedTokenIds = super.expected_token_ids();
        errorLookAheadSize = RECOVERY_ERROR_LOOKAHEAD_SIZE;
        return expectedTokenIds;
    }

    @Override
    protected int error_sync_size() {
        return errorLookAheadSize;
    }
:};

/* Terminals (tokens returned by the scanner) */
terminal AND, OR;
terminal EQUAL_TO, LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUAL_TO, GREATER_THAN_OR_EQUAL_TO, NOT_EQUAL_TO;
terminal TIMES, PLUS, MINUS, DIVIDE;
terminal IF, ELSE;
terminal ASSIGNMENT;
terminal String IDENTIFIER;
terminal CODE, API;
terminal SEMICOLON, COMMA, LEFT_PARENTHESIS, RIGHT_PARENTHESIS, COLON, DOT;
terminal Integer INTEGER;
terminal Double REAL;
terminal String STRING;

/* Non terminals */
non terminal Statement Statement;
non terminal Statement StatementWithSemicolon;
non terminal List<Statement> StatementList;
non terminal Expression Expression;
non terminal Program Program;
non terminal TypeDeclaration TypeDeclaration;
non terminal TypeExpression TypeExpression;
non terminal IntegerConstant IntegerConstant;
non terminal RealConstant RealConstant;
non terminal StringConstant StringConstant;

/* Precedences */
precedence left PLUS, MINUS, TIMES, DIVIDE;

/* Start symbol */
start with Program;

/* The grammar rules */
Program ::= StatementList:statementList                                         {: RESULT=Program.of(statementList); :}
    ;
StatementList ::= StatementWithSemicolon:statement StatementList:statementList  {: statementList.add(statement); RESULT=statementList; :}
    | /* Empty StatementList */                                                 {: RESULT=new LinkedList<Statement>(); :}
    ;
StatementWithSemicolon ::= Statement:statement SEMICOLON                        {: RESULT=statement; :}
    | error SEMICOLON                                                           {: RESULT=StatementSyntaxError.of(syntaxError); :}
    ;
Statement ::= TypeDeclaration:typeDeclaration ASSIGNMENT Expression:expression  {: RESULT=TypeDeclarationAssignment.of(typeDeclaration, expression); :}
    | TypeExpression:type ASSIGNMENT Expression:expression                      {: RESULT=ExistingTypeAssignment.of(type, expression); :}
    ;
TypeDeclaration ::= TypeExpression:targetType COLON TypeExpression:existingType {: RESULT=TypeDeclaration.of(targetType, existingType); :}
    ;
TypeExpression ::= IDENTIFIER:type                                              {: RESULT=TypeExpression.of(location(typexleft, typexright), type); :}
    ;
Expression ::= INTEGER:value                                                    {: RESULT=IntegerConstant.of(location(valuexleft, valuexright), value); :}
    | REAL:value                                                                {: RESULT=RealConstant.of(location(valuexleft, valuexright), value); :}
    | STRING:value                                                              {: RESULT=StringConstant.of(location(valuexleft, valuexright), value); :}
    | TypeExpression:type                                                       {: RESULT=type; :}
    | Expression:left PLUS Expression:right                                     {: RESULT=Addition.add(left, right); :}
    ;
